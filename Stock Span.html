<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stock Span Problem — Structured Notes</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --card: #0b1220;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #22d3ee;
      --accent-2: #a78bfa;
      --ok: #34d399;
      --warn: #fbbf24;
      --danger: #fb7185;
      --code-bg: #0b1020;
      --border: #1f2937;
      --shadow: 0 10px 30px rgba(0,0,0,0.45);
      --radius: 14px;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 80% -50%, #18263a 0%, var(--bg) 60%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.6;
      overflow-y: overlay;
    }
    .container {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 24px;
      max-width: 1200px;
      margin: 20px auto;
      padding: 0 16px 40px;
    }
    .sidebar {
      position: sticky; top: 20px; align-self: start;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid var(--border); border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 16px;
    }
    .sidebar h3 { margin: 0 0 10px; font-size: 16px; color: var(--muted); font-weight: 600; letter-spacing: .3px; }
    .toc { list-style: none; padding: 0; margin: 0; }
    .toc li { margin: 6px 0; }
    .toc a { display: block; text-decoration: none; color: var(--text); padding: 8px 10px; border-radius: 10px; transition: all .15s ease; border: 1px solid transparent; }
    .toc a:hover { background: #0b1220; border-color: var(--border); color: #ffffff; }
    .main { display: flex; flex-direction: column; gap: 18px; }
    .hero { position: relative; background: linear-gradient(180deg, rgba(167,139,250,0.10), rgba(34,211,238,0.06)); border: 1px solid var(--border); border-radius: var(--radius); padding: 26px 22px; box-shadow: var(--shadow); overflow: hidden; }
    .hero:after { content: ""; position: absolute; top: -40px; right: -60px; width: 220px; height: 220px; background: radial-gradient(120px 120px at 60% 40%, rgba(34,211,238,.35), rgba(34,211,238,0) 70%); filter: blur(6px); pointer-events: none; }
    .title { margin: 0; font-size: 28px; letter-spacing: .2px; }
    .subtitle { margin: 6px 0 0; color: var(--muted); }
    .chips { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    .chip { padding: 4px 8px; border: 1px solid var(--border); background: #0b1220; border-radius: 999px; color: var(--muted); font-size: 12px; }
    section.card { background: linear-gradient(180deg, rgba(255,255,255,0.035), rgba(255,255,255,0.015)); border: 1px solid var(--border); border-radius: var(--radius); padding: 18px 18px; box-shadow: var(--shadow); }
    h2 { margin: 0 0 10px; font-size: 20px; }
    h3 { margin: 16px 0 8px; font-size: 16px; color: var(--accent-2); }
    p { margin: 8px 0; }
    ul { margin: 8px 0 8px 18px; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    .note { color: var(--muted); font-size: 14px; }
    .pill { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; background: #0b1220; border: 1px solid var(--border); color: var(--text); font-size: 13px; }
    .pill b { color: var(--accent); }
    details { border: 1px solid var(--border); border-radius: 12px; background: #0b1220; }
    summary { list-style: none; cursor: pointer; padding: 12px 14px; font-weight: 600; color: #dbeafe; border-bottom: 1px solid var(--border); user-select: none; }
    summary::-webkit-details-marker { display:none; }
    .details-body { padding: 12px 14px; color: var(--text); }
    table { width: 100%; border-collapse: collapse; overflow: hidden; border-radius: 12px; }
    th, td { padding: 10px 12px; border-bottom: 1px solid var(--border); }
    th { text-align: left; color: #c7d2fe; font-weight: 600; background: rgba(167,139,250,0.08); }
    tr:last-child td { border-bottom: none; }
    pre, code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; padding: 12px; overflow: auto; }
    code { background: rgba(255,255,255,0.03); padding: 2px 6px; border-radius: 6px; border: 1px solid var(--border); color: #e2e8f0; }
    .callout { border-left: 3px solid var(--accent); background: linear-gradient(90deg, rgba(34,211,238,0.07), rgba(34,211,238,0.02)); padding: 10px 12px; border-radius: 10px; margin: 10px 0; }
    .formula { background: #0b1220; border: 1px dashed #1f334d; padding: 10px 12px; border-radius: 10px; }
    .footer-note { color: var(--muted); font-size: 13px; text-align: center; margin-top: 10px; }
    @media (max-width: 960px) { .container { grid-template-columns: 1fr; } .sidebar { position: static; order: -1; } }

    /* Quiz helpers */
    .quiz { display: grid; gap: 12px; }
    .quiz .q { border: 1px solid var(--border); border-radius: 12px; background: #0b1220; padding: 12px; }
    .quiz .choice { display: block; margin: 6px 0; }
    .quiz .ans { display: none; margin-top: 8px; color: var(--ok); }
    .quiz .reveal { margin-top: 8px; }
    .quiz button { background: #0b1220; color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 6px 10px; cursor: pointer; }
    .quiz button:hover { border-color: var(--accent); color: #ffffff; }
  </style>
</head>
<body>
  <div class="container">
    <aside class="sidebar">
      <h3>On this page</h3>
      <ul class="toc">
        <li><a href="#intro">Introduction</a></li>
        <li><a href="#example">Example & Breakdown</a></li>
        <li><a href="#brute">Brute-Force Baseline</a></li>
        <li><a href="#two-pass">Greedy Criterion & Invariant</a></li>
        <li><a href="#single-pass">Single-Pass Stack Algorithm</a></li>
        <li><a href="#dry-run">Dry Run</a></li>
        <li><a href="#pseudocode">Pseudocode & Implementations</a></li>
        <li><a href="#conclusion">Conclusion + Quiz</a></li>
      </ul>
    </aside>

    <main class="main">
      <header class="hero">
        <h1 class="title">Stock Span Problem | Monotonic Stack</h1>
        <p class="subtitle">For each trading day, compute how many consecutive previous days had a price less than or equal to today’s price.</p>
        <div class="chips">
          <span class="chip">Stack</span>
          <span class="chip">Monotonic</span>
          <span class="chip">Nearest Greater to Left</span>
          <span class="chip">O(N)</span>
          <span class="chip">Arrays</span>
        </div>
        <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
          <span class="pill"><b>Reading time:</b> ~10 min</span>
          <span class="pill"><b>Keywords:</b> stock span, online stock span, monotonic stack, nearest greater to left, O(N)</span>
        </div>
      </header>

      <section id="intro" class="card">
        <h2>Introduction</h2>
        <p>Given an array of daily stock prices, the <b>span</b> on day <code>i</code> is the number of consecutive days ending at <code>i</code> for which the price was <b>≤ price[i]</b>. Return an array of spans for all days. In the online version, expose <code>next(price)</code> that returns today’s span as prices stream in.</p>

        <h3>Summary</h3>
        <ul>
          <li>Maintain a <b>monotonically decreasing</b> stack of price-index pairs.</li>
          <li>While stack top price ≤ current price, <b>pop</b> (those days are covered by current span).</li>
          <li>If stack becomes empty, span = <code>i + 1</code>; else span = <code>i - top.index</code>.</li>
          <li>Push the current <code>(price, i)</code> and record span; each element is pushed and popped at most once ⇒ <b>O(N)</b>.</li>
          <li>Space is <b>O(N)</b> in the worst case (strictly decreasing prices).</li>
        </ul>
      </section>

      <section id="example" class="card">
        <h2>Example & Breakdown</h2>
        <p>Example prices: <code>[100, 80, 60, 70, 60, 75, 85]</code></p>
        <ul>
          <li>Interpretation: For each day, count how many consecutive days back had price ≤ today’s.</li>
          <li>Expected spans: <code>[1, 1, 1, 2, 1, 4, 6]</code>.</li>
          <li>Intuition: A higher price “absorbs” previous lower-or-equal prices until a greater price stops the span.</li>
        </ul>
        <div class="callout">The span is equivalent to the distance to the <b>nearest greater element to the left</b> (or to start if none).</div>
      </section>

      <section id="brute" class="card">
        <h2>Brute-Force Baseline</h2>
        <ul>
          <li>For each day <code>i</code>, scan leftward while <code>price[j] ≤ price[i]</code> to count consecutive days.</li>
          <li>Nested loops in the worst case: each day may scan back through all previous days.</li>
          <li><b>Time:</b> O(N^2). <b>Space:</b> O(1) extra.</li>
        </ul>
      </section>

      <section id="two-pass" class="card">
        <h2>Greedy Criterion & Invariant</h2>
        <p>Maintain a stack that is strictly decreasing in price from bottom to top. This ensures the top is the nearest day to the left with a price greater than today’s.</p>
        <ul>
          <li>Pop while <code>top.price ≤ current.price</code> to discard days dominated by today’s higher price.</li>
          <li>If the stack is empty, no greater price exists to the left ⇒ span covers all previous days plus today.</li>
          <li>Otherwise, the nearest greater-to-left day at <code>top.index</code> bounds the span.</li>
        </ul>
      </section>

      <section id="single-pass" class="card">
        <h2>Single-Pass Stack Algorithm</h2>
        <ul>
          <li>Initialize empty stack of pairs <code>(price, index)</code> and an empty result list.</li>
          <li>For each day <code>i</code> from left to right:</li>
          <li style="list-style:none; margin-left:0;">
            <ul>
              <li>While stack not empty and <code>stack.top().price ≤ price[i]</code>, pop.</li>
              <li>If stack empty ⇒ span = <code>i + 1</code>; else span = <code>i - stack.top().index</code>.</li>
              <li>Push <code>(price[i], i)</code> and append span to result.</li>
            </ul>
          </li>
          <li>Return the result list of spans.</li>
        </ul>
        <p class="note">The online variant exposes <code>next(val)</code> that applies the same logic incrementally and returns today’s span.</p>
      </section>

      <section id="dry-run" class="card">
        <h2>Dry Run</h2>
        <p>Prices: <code>[100, 80, 60, 70, 60, 75, 85]</code></p>
        <div class="details-body">
          <ul>
            <li>Start: stack = [], result = []</li>
            <li><b>Day 0 (100)</b>: stack empty ⇒ span = 1; push (100,0). result = [1]; stack = [(100,0)]</li>
            <li><b>Day 1 (80)</b>: top 100 > 80 ⇒ span = 1 - 0 = 1; push (80,1). result = [1,1]</li>
            <li><b>Day 2 (60)</b>: top 80 > 60 ⇒ span = 2 - 1 = 1; push (60,2). result = [1,1,1]</li>
            <li><b>Day 3 (70)</b>: pop (60,2); top 80 > 70 ⇒ span = 3 - 1 = 2; push (70,3). result = [1,1,1,2]</li>
            <li><b>Day 4 (60)</b>: top 70 > 60 ⇒ span = 4 - 3 = 1; push (60,4). result = [1,1,1,2,1]</li>
            <li><b>Day 5 (75)</b>: pop (60,4), pop (70,3); top 80 > 75 ⇒ span = 5 - 1 = 4; push (75,5). result = [1,1,1,2,1,4]</li>
            <li><b>Day 6 (85)</b>: pop (75,5), pop (80,1); top 100 > 85 ⇒ span = 6 - 0 = 6; push (85,6). result = [1,1,1,2,1,4,6]</li>
          </ul>
        </div>
        <div class="callout"><b>Check:</b> result is <code>[1, 1, 1, 2, 1, 4, 6]</code> as expected.</div>
      </section>

      <section id="pseudocode" class="card">
        <h2>Pseudocode & Implementations</h2>
        <pre><code class="language-text">function stockSpan(prices):
    st = empty stack of pairs (price, index)
    spans = empty list
    for i from 0 to prices.length-1:
        while st not empty and st.top().price &lt;= prices[i]:
            st.pop()
        if st empty:
            span = i + 1
        else:
            span = i - st.top().index
        st.push((prices[i], i))
        spans.append(span)
    return spans
</code></pre>

        <h3>C++ Implementation (Array version)</h3>
        <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; stockSpan(const vector&lt;int&gt;& prices) {
    vector&lt;int&gt; span;
    span.reserve(prices.size());
    // pair: (price, index)
    vector&lt;pair&lt;int,int&gt;&gt; st;
    st.reserve(prices.size());
    for (int i = 0; i &lt; (int)prices.size(); ++i) {
        while (!st.empty() && st.back().first &lt;= prices[i]) st.pop_back();
        int s = st.empty() ? i + 1 : i - st.back().second;
        span.push_back(s);
        st.emplace_back(prices[i], i);
    }
    return span;
}
</code></pre>

        <h3>Java Implementation (Online class)</h3>
        <pre><code class="language-java">import java.util.*;

class StockSpanner {
    // pair: int[]{price, index}
    private Deque&lt;int[]&gt; st = new ArrayDeque&lt;&gt;();
    private int index = -1;

    public int next(int price) {
        index++;
        while (!st.isEmpty() &amp;&amp; st.peekLast()[0] &lt;= price) {
            st.pollLast();
        }
        int span = st.isEmpty() ? index + 1 : index - st.peekLast()[1];
        st.addLast(new int[]{price, index});
        return span;
    }
}
</code></pre>

        <h3>Complexity</h3>
        <ul>
          <li><b>Time:</b> O(N). Each day’s price is pushed and popped at most once.</li>
          <li><b>Space:</b> O(N) in the worst case (strictly decreasing prices).</li>
        </ul>
      </section>

      <section id="conclusion" class="card">
        <h2>Conclusion</h2>
        <ul>
          <li>Span equals distance to the nearest greater price on the left (or start if none).</li>
          <li>A monotonically decreasing stack yields a clean O(N) solution.</li>
          <li>The approach works in batch (array) and online (streaming via <code>next</code>).</li>
          <li>Worst-case memory occurs on strictly decreasing sequences.</li>
        </ul>

        <h3>Interactive Quiz</h3>
        <div class="quiz" id="quiz">
          <!-- Q1 MCQ -->
          <div class="q">
            <div><b>1) What does the span on day i represent?</b></div>
            <label class="choice"><input type="radio" name="q1"> The maximum price seen so far</label>
            <label class="choice"><input type="radio" name="q1"> The number of consecutive previous days with price ≤ price[i]</label>
            <label class="choice"><input type="radio" name="q1"> The number of future days with price ≥ price[i]</label>
            <label class="choice"><input type="radio" name="q1"> The index of the previous greater element</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">The number of consecutive previous days with price ≤ price[i].</div></details>
          </div>

          <!-- Q2 MCQ -->
          <div class="q">
            <div><b>2) What invariant does the stack maintain?</b></div>
            <label class="choice"><input type="radio" name="q2"> Increasing by index, arbitrary by price</label>
            <label class="choice"><input type="radio" name="q2"> Monotonically decreasing in price</label>
            <label class="choice"><input type="radio" name="q2"> Monotonically increasing in price</label>
            <label class="choice"><input type="radio" name="q2"> Sorted by span</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">Monotonically decreasing in price.</div></details>
          </div>

          <!-- Q3 SA -->
          <div class="q">
            <div><b>3) Short answer:</b> What is the span formula when the stack is not empty?</div>
            <button data-target="a3">Reveal answer</button>
            <div id="a3" class="ans">span = i - stack.top().index</div>
          </div>

          <!-- Q4 MCQ -->
          <div class="q">
            <div><b>4) Which condition triggers popping from the stack during processing of day i?</b></div>
            <label class="choice"><input type="radio" name="q4"> Current price is strictly less than top price</label>
            <label class="choice"><input type="radio" name="q4"> Current price is greater than or equal to top price</label>
            <label class="choice"><input type="radio" name="q4"> The stack size exceeds log N</label>
            <label class="choice"><input type="radio" name="q4"> The previous span is zero</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">Current price is greater than or equal to the top price (≤ condition for popping).</div></details>
          </div>

          <!-- Q5 SA -->
          <div class="q">
            <div><b>5) Short answer:</b> For prices [100, 80, 60, 70, 60, 75, 85], what is the span on day 5 (price 75)?</div>
            <button data-target="a5">Reveal answer</button>
            <div id="a5" class="ans">4</div>
          </div>

          <!-- Q6 MCQ -->
          <div class="q">
            <div><b>6) What is the time complexity of the stack-based algorithm over N days?</b></div>
            <label class="choice"><input type="radio" name="q6"> O(N log N)</label>
            <label class="choice"><input type="radio" name="q6"> O(N)</label>
            <label class="choice"><input type="radio" name="q6"> O(N^2)</label>
            <label class="choice"><input type="radio" name="q6"> O(1)</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">O(N), each element is pushed and popped at most once.</div></details>
          </div>

          <!-- Q7 SA -->
          <div class="q">
            <div><b>7) Short answer:</b> In the online class, which method returns today’s span?</div>
            <button data-target="a7">Reveal answer</button>
            <div id="a7" class="ans">next(price)</div>
          </div>

          <!-- Q8 MCQ -->
          <div class="q">
            <div><b>8) Why is the brute-force approach O(N^2)?</b></div>
            <label class="choice"><input type="radio" name="q8"> It uses recursion</label>
            <label class="choice"><input type="radio" name="q8"> Each day may scan all previous days in the worst case</label>
            <label class="choice"><input type="radio" name="q8"> It stores all spans</label>
            <label class="choice"><input type="radio" name="q8"> It sorts the prices each day</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">Each day may scan all previous days in the worst case.</div></details>
          </div>

          <!-- Q9 SA -->
          <div class="q">
            <div><b>9) Short answer:</b> What data do we store for each item on the stack?</div>
            <button data-target="a9">Reveal answer</button>
            <div id="a9" class="ans">A pair: (price, index).</div>
          </div>

          <!-- Q10 SA -->
          <div class="q">
            <div><b>10) Short answer:</b> Give the final spans for [100, 80, 60, 70, 60, 75, 85].</div>
            <button data-target="a10">Reveal answer</button>
            <div id="a10" class="ans">[1, 1, 1, 2, 1, 4, 6]</div>
          </div>

          <!-- Q11 MCQ -->
          <div class="q">
            <div><b>11) What happens if the stack becomes empty while processing day i?</b></div>
            <label class="choice"><input type="radio" name="q11"> Span is zero</label>
            <label class="choice"><input type="radio" name="q11"> Span is i</label>
            <label class="choice"><input type="radio" name="q11"> Span is i + 1</label>
            <label class="choice"><input type="radio" name="q11"> We restart the algorithm</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">Span is i + 1 (all previous days were ≤ current).</div></details>
          </div>

          <!-- Q12 SA -->
          <div class="q">
            <div><b>12) Short answer:</b> What input pattern maximizes stack size?</div>
            <button data-target="a12">Reveal answer</button>
            <div id="a12" class="ans">Strictly decreasing prices (e.g., 100, 90, 80, ...).</div>
          </div>
        </div>
      </section>

      <div class="footer-note">Optimized for quick revision. 🚀</div>
    </main>
  </div>

  <script>
  // Simple toggle for short-answer reveal buttons
  (function () {
    document.querySelectorAll('.quiz button[data-target]').forEach(function(btn) {
      btn.addEventListener('click', function() {
        var id = btn.getAttribute('data-target');
        var ans = document.getElementById(id);
        if (!ans) return;
        var visible = ans.style.display === 'block';
        ans.style.display = visible ? 'none' : 'block';
        btn.textContent = visible ? 'Reveal answer' : 'Hide answer';
      });
    });
  })();
  </script>
</body>
</html>


