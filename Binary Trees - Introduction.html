<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Binary Trees â€” Structured Notes</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --card: #0b1220;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #22d3ee;
      --accent-2: #a78bfa;
      --ok: #34d399;
      --warn: #fbbf24;
      --danger: #fb7185;
      --code-bg: #0b1020;
      --border: #1f2937;
      --shadow: 0 10px 30px rgba(0,0,0,0.45);
      --radius: 14px;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 80% -50%, #18263a 0%, var(--bg) 60%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.6;
      overflow-y: overlay;
    }
    .container {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 24px;
      max-width: 1200px;
      margin: 20px auto;
      padding: 0 16px 40px;
    }
    .sidebar {
      position: sticky; top: 20px; align-self: start;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid var(--border); border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 16px;
    }
    .sidebar h3 { margin: 0 0 10px; font-size: 16px; color: var(--muted); font-weight: 600; letter-spacing: .3px; }
    .toc { list-style: none; padding: 0; margin: 0; }
    .toc li { margin: 6px 0; }
    .toc a { display: block; text-decoration: none; color: var(--text); padding: 8px 10px; border-radius: 10px; transition: all .15s ease; border: 1px solid transparent; }
    .toc a:hover { background: #0b1220; border-color: var(--border); color: #ffffff; }
    .main { display: flex; flex-direction: column; gap: 18px; }
    .hero { position: relative; background: linear-gradient(180deg, rgba(167,139,250,0.10), rgba(34,211,238,0.06)); border: 1px solid var(--border); border-radius: var(--radius); padding: 26px 22px; box-shadow: var(--shadow); overflow: hidden; }
    .hero:after { content: ""; position: absolute; top: -40px; right: -60px; width: 220px; height: 220px; background: radial-gradient(120px 120px at 60% 40%, rgba(34,211,238,.35), rgba(34,211,238,0) 70%); filter: blur(6px); pointer-events: none; }
    .title { margin: 0; font-size: 28px; letter-spacing: .2px; }
    .subtitle { margin: 6px 0 0; color: var(--muted); }
    .chips { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    .chip { padding: 4px 8px; border: 1px solid var(--border); background: #0b1220; border-radius: 999px; color: var(--muted); font-size: 12px; }
    section.card { background: linear-gradient(180deg, rgba(255,255,255,0.035), rgba(255,255,255,0.015)); border: 1px solid var(--border); border-radius: var(--radius); padding: 18px 18px; box-shadow: var(--shadow); }
    h2 { margin: 0 0 10px; font-size: 20px; }
    h3 { margin: 16px 0 8px; font-size: 16px; color: var(--accent-2); }
    p { margin: 8px 0; }
    ul { margin: 8px 0 8px 18px; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    .note { color: var(--muted); font-size: 14px; }
    .pill { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; background: #0b1220; border: 1px solid var(--border); color: var(--text); font-size: 13px; }
    .pill b { color: var(--accent); }
    details { border: 1px solid var(--border); border-radius: 12px; background: #0b1220; }
    summary { list-style: none; cursor: pointer; padding: 12px 14px; font-weight: 600; color: #dbeafe; border-bottom: 1px solid var(--border); user-select: none; }
    summary::-webkit-details-marker { display:none; }
    .details-body { padding: 12px 14px; color: var(--text); }
    table { width: 100%; border-collapse: collapse; overflow: hidden; border-radius: 12px; }
    th, td { padding: 10px 12px; border-bottom: 1px solid var(--border); }
    th { text-align: left; color: #c7d2fe; font-weight: 600; background: rgba(167,139,250,0.08); }
    tr:last-child td { border-bottom: none; }
    pre, code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; padding: 12px; overflow: auto; }
    code { background: rgba(255,255,255,0.03); padding: 2px 6px; border-radius: 6px; border: 1px solid var(--border); color: #e2e8f0; }
    .callout { border-left: 3px solid var(--accent); background: linear-gradient(90deg, rgba(34,211,238,0.07), rgba(34,211,238,0.02)); padding: 10px 12px; border-radius: 10px; margin: 10px 0; }
    .formula { background: #0b1220; border: 1px dashed #1f334d; padding: 10px 12px; border-radius: 10px; }
    .footer-note { color: var(--muted); font-size: 13px; text-align: center; margin-top: 10px; }
    @media (max-width: 960px) { .container { grid-template-columns: 1fr; } .sidebar { position: static; order: -1; } }

    /* Quiz helpers */
    .quiz { display: grid; gap: 12px; }
    .quiz .q { border: 1px solid var(--border); border-radius: 12px; background: #0b1220; padding: 12px; }
    .quiz .choice { display: block; margin: 6px 0; }
    .quiz .ans { display: none; margin-top: 8px; color: var(--ok); }
    .quiz .reveal { margin-top: 8px; }
    .quiz button { background: #0b1220; color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 6px 10px; cursor: pointer; }
    .quiz button:hover { border-color: var(--accent); color: #ffffff; }
  </style>
</head>
<body>
  <div class="container">
    <aside class="sidebar">
      <h3>On this page</h3>
      <ul class="toc">
        <li><a href="#intro">Introduction</a></li>
        <li><a href="#example">Core Concepts & Examples</a></li>
        <li><a href="#brute">Types of Binary Trees</a></li>
        <li><a href="#two-pass">Height, Balance & Properties</a></li>
        <li><a href="#single-pass">Traversal Techniques</a></li>
        <li><a href="#dry-run">Worked Example</a></li>
        <li><a href="#pseudocode">Implementations (C++ & Java)</a></li>
        <li><a href="#conclusion">Conclusion + Quiz</a></li>
      </ul>
    </aside>

    <main class="main">
      <header class="hero">
        <h1 class="title">Binary Trees â€” Introduction & Types</h1>
        <p class="subtitle">A practical overview of binary trees: terminology, common types (full, complete, perfect, balanced, degenerate), and fundamental traversals.</p>
        <div class="chips">
          <span class="chip">Binary Trees</span>
          <span class="chip">Data Structures</span>
          <span class="chip">Traversal</span>
          <span class="chip">O(log N)</span>
          <span class="chip">Hierarchy</span>
        </div>
        <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
          <span class="pill"><b>Reading time:</b> ~11 min</span>
          <span class="pill"><b>Keywords:</b> binary tree, root, child, leaf, subtree, full, complete, perfect, balanced, degenerate, traversal</span>
        </div>
      </header>

      <section id="intro" class="card">
        <h2>Introduction</h2>
        <p>A binary tree is a hierarchical data structure in which each node has at most two children (commonly referred to as the left child and the right child). Unlike arrays, stacks, and queuesâ€”which are linearâ€”trees capture parentâ€“child relationships and naturally model hierarchies such as file systems.</p>

        <h3>Summary</h3>
        <ul>
          <li>Each node has at most two children: left and right.</li>
          <li>Key terms: root, children, leaf, subtree, ancestor/descendant, level, height.</li>
          <li>Common types: full, complete, perfect, balanced, and degenerate (skewed).</li>
          <li>Balanced trees enable operations with height â‰ˆ O(log N).</li>
          <li>Core traversals: preorder, inorder, postorder, and level-order (BFS).</li>
        </ul>
      </section>

      <section id="example" class="card">
        <h2>Core Concepts & Examples</h2>
        <ul>
          <li><b>Root:</b> The unique topmost node, from which the tree originates.</li>
          <li><b>Children:</b> Nodes directly connected below a node; a node can have 0, 1, or 2 children.</li>
          <li><b>Leaf:</b> A node with no children.</li>
          <li><b>Subtree:</b> Any node together with all of its descendants.</li>
          <li><b>Ancestors/Descendants:</b> On the path upward/downward from a node respectively.</li>
          <li><b>Level (Depth):</b> Distance in edges from the root (root at level 0).</li>
          <li><b>Height:</b> Longest downward path from a node to a leaf (height of a leaf is 0).</li>
        </ul>
        <div class="callout">Thinking in hierarchies helps: a folder contains subfolders and files; similarly, a node contains subtrees and leaves.</div>
      </section>

      <section id="brute" class="card">
        <h2>Types of Binary Trees</h2>
        <ul>
          <li><b>Full Binary Tree:</b> Every node has either 0 or 2 children (no node has exactly one child).</li>
          <li><b>Complete Binary Tree:</b> All levels are completely filled except possibly the last, and the last levelâ€™s nodes are as far left as possible.</li>
          <li><b>Perfect Binary Tree:</b> All leaf nodes are at the same level; equivalently, every internal node has exactly 2 children and every level is full.</li>
          <li><b>Balanced Binary Tree:</b> Height grows on the order of O(log N). Many implementations enforce a small height difference between subtrees (e.g., AVL, Redâ€“Black).</li>
          <li><b>Degenerate (Skewed) Tree:</b> Every node has only one child, producing a structure like a linked list.</li>
        </ul>
      </section>

      <section id="two-pass" class="card">
        <h2>Height, Balance & Properties</h2>
        <ul>
          <li><b>Height bounds:</b> For N nodes, 0 â‰¤ height â‰¤ Nâˆ’1; balanced trees aim near logâ‚‚(N).</li>
          <li><b>Perfect tree size:</b> For height h, total nodes N = 2^(h+1) âˆ’ 1 and leaves L = 2^h.</li>
          <li><b>Why balance matters:</b> Search/insert/delete on trees like BSTs benefit from logarithmic height.</li>
          <li><b>Completeness vs Perfectness:</b> Every perfect tree is complete; not every complete tree is perfect.</li>
          <li><b>Skew impact:</b> Degenerate trees behave like linked lists with O(N) height.</li>
        </ul>
        <div class="formula"><code>N = 2^{h+1} - 1</code>, <code>L = 2^{h}</code> for a perfect tree of height <code>h</code>.</div>
      </section>

      <section id="single-pass" class="card">
        <h2>Traversal Techniques</h2>
        <ul>
          <li><b>Preorder (Root, Left, Right):</b> Visits root before subtrees; useful for copying or serializing a tree.</li>
          <li><b>Inorder (Left, Root, Right):</b> Yields sorted order on Binary Search Trees.</li>
          <li><b>Postorder (Left, Right, Root):</b> Frees subtrees before the root; useful for deletion and computing subtree properties.</li>
          <li><b>Level-order (BFS):</b> Visits nodes level by level; helpful for completeness checks and shortest path in unweighted trees.</li>
        </ul>
        <p class="note">Recursive definitions are concise and readable; iterative variants with stacks/queues are common for large trees to avoid deep recursion.</p>
      </section>

      <section id="dry-run" class="card">
        <h2>Worked Example</h2>
        <p>Consider the tree with root 1, children 2 and 3; node 2 has children 4 and 5; node 3 has a single left child 6.</p>
        <div class="details-body">
          <ul>
            <li>Preorder: 1, 2, 4, 5, 3, 6</li>
            <li>Inorder: 4, 2, 5, 1, 6, 3</li>
            <li>Postorder: 4, 5, 2, 6, 3, 1</li>
            <li>Level-order: 1 | 2, 3 | 4, 5, 6</li>
            <li>Type checks: not full (node 3 has one child), not perfect (leaves at different levels), not balanced if height is large relative to N; completeness depends on level-order positioning.</li>
          </ul>
        </div>
        <div class="callout"><b>Tip:</b> To check completeness, ensure no node appears on the right when a left position is missing at the last level.</div>
      </section>

      <section id="pseudocode" class="card">
        <h2>Implementations (C++ & Java)</h2>
        <h3>C++: Node definition and traversals</h3>
        <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

void preorder(TreeNode* root, vector&lt;int&gt;&amp; out) {
    if (!root) return;
    out.push_back(root-&gt;val);
    preorder(root-&gt;left, out);
    preorder(root-&gt;right, out);
}

void inorder(TreeNode* root, vector&lt;int&gt;&amp; out) {
    if (!root) return;
    inorder(root-&gt;left, out);
    out.push_back(root-&gt;val);
    inorder(root-&gt;right, out);
}

void postorder(TreeNode* root, vector&lt;int&gt;&amp; out) {
    if (!root) return;
    postorder(root-&gt;left, out);
    postorder(root-&gt;right, out);
    out.push_back(root-&gt;val);
}

vector&lt;int&gt; levelOrder(TreeNode* root) {
    vector&lt;int&gt; out; if (!root) return out;
    queue&lt;TreeNode*&gt; q; q.push(root);
    while (!q.empty()) {
        auto* node = q.front(); q.pop();
        out.push_back(node-&gt;val);
        if (node-&gt;left) q.push(node-&gt;left);
        if (node-&gt;right) q.push(node-&gt;right);
    }
    return out;
}

// Check if full: every node has 0 or 2 children
bool isFull(TreeNode* root) {
    if (!root) return true;
    bool hasLeft = root-&gt;left != nullptr, hasRight = root-&gt;right != nullptr;
    if (hasLeft != hasRight) return false;
    return isFull(root-&gt;left) &amp;&amp; isFull(root-&gt;right);
}

// Check completeness via BFS
bool isComplete(TreeNode* root) {
    if (!root) return true;
    queue&lt;TreeNode*&gt; q; q.push(root);
    bool seenNull = false;
    while (!q.empty()) {
        TreeNode* cur = q.front(); q.pop();
        if (!cur) { seenNull = true; continue; }
        if (seenNull) return false; // non-null after null in level-order
        q.push(cur-&gt;left);
        q.push(cur-&gt;right);
    }
    return true;
}

// Height (edges). Returns -1 for null so leaf has height 0
int height(TreeNode* root) {
    if (!root) return -1;
    return 1 + max(height(root-&gt;left), height(root-&gt;right));
}

// Balanced if for every node the subtree heights differ by at most 1
pair&lt;bool,int&gt; checkBalanced(TreeNode* root) {
    if (!root) return {true, -1};
    auto [lb, lh] = checkBalanced(root-&gt;left);
    auto [rb, rh] = checkBalanced(root-&gt;right);
    bool ok = lb &amp;&amp; rb &amp;&amp; abs(lh - rh) &lt;= 1;
    return {ok, 1 + max(lh, rh)};
}

bool isPerfect(TreeNode* root) {
    if (!root) return true;
    int h = height(root);
    // Perfect iff all leaves at same depth and all internal nodes have 2 children
    function&lt;bool(TreeNode*, int)&gt; dfs = [&](TreeNode* node, int depth) {
        if (!node) return true;
        if (!node-&gt;left &amp;&amp; !node-&gt;right) return depth == h;
        if (!node-&gt;left || !node-&gt;right) return false;
        return dfs(node-&gt;left, depth + 1) &amp;&amp; dfs(node-&gt;right, depth + 1);
    };
    return dfs(root, 0);
}
</code></pre>

        <h3>Java: Node definition and traversals</h3>
        <pre><code class="language-java">import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int x) { val = x; }
}

class BinaryTreeUtils {
    static void preorder(TreeNode root, List&lt;Integer&gt; out) {
        if (root == null) return;
        out.add(root.val);
        preorder(root.left, out);
        preorder(root.right, out);
    }

    static void inorder(TreeNode root, List&lt;Integer&gt; out) {
        if (root == null) return;
        inorder(root.left, out);
        out.add(root.val);
        inorder(root.right, out);
    }

    static void postorder(TreeNode root, List&lt;Integer&gt; out) {
        if (root == null) return;
        postorder(root.left, out);
        postorder(root.right, out);
        out.add(root.val);
    }

    static List&lt;Integer&gt; levelOrder(TreeNode root) {
        List&lt;Integer&gt; out = new ArrayList&lt;&gt;();
        if (root == null) return out;
        Queue&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;();
        q.offer(root);
        while (!q.isEmpty()) {
            TreeNode node = q.poll();
            out.add(node.val);
            if (node.left != null) q.offer(node.left);
            if (node.right != null) q.offer(node.right);
        }
        return out;
    }

    static boolean isFull(TreeNode root) {
        if (root == null) return true;
        boolean hasLeft = root.left != null, hasRight = root.right != null;
        if (hasLeft ^ hasRight) return false;
        return isFull(root.left) &amp;&amp; isFull(root.right);
    }

    static boolean isComplete(TreeNode root) {
        if (root == null) return true;
        Queue&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;();
        q.offer(root);
        boolean seenNull = false;
        while (!q.isEmpty()) {
            TreeNode cur = q.poll();
            if (cur == null) { seenNull = true; continue; }
            if (seenNull) return false;
            q.offer(cur.left);
            q.offer(cur.right);
        }
        return true;
    }

    static int height(TreeNode root) {
        if (root == null) return -1;
        return 1 + Math.max(height(root.left), height(root.right));
    }

    static class Pair { boolean ok; int h; Pair(boolean o, int hh){ ok=o; h=hh; } }

    static Pair checkBalanced(TreeNode root) {
        if (root == null) return new Pair(true, -1);
        Pair L = checkBalanced(root.left);
        Pair R = checkBalanced(root.right);
        boolean ok = L.ok &amp;&amp; R.ok &amp;&amp; Math.abs(L.h - R.h) &lt;= 1;
        return new Pair(ok, 1 + Math.max(L.h, R.h));
    }

    static boolean isPerfect(TreeNode root) {
        int h = height(root);
        return isPerfectAtDepth(root, 0, h);
    }

    private static boolean isPerfectAtDepth(TreeNode node, int depth, int h) {
        if (node == null) return true;
        if (node.left == null &amp;&amp; node.right == null) return depth == h;
        if (node.left == null || node.right == null) return false;
        return isPerfectAtDepth(node.left, depth + 1, h) &amp;&amp; isPerfectAtDepth(node.right, depth + 1, h);
    }
}
</code></pre>

        <h3>Complexity</h3>
        <ul>
          <li><b>Traversals:</b> Visit each node once â‡’ O(N) time, O(H) stack space (recursion) or O(N) with explicit queue for BFS.</li>
          <li><b>Checks (full, complete, perfect, balanced):</b> O(N) time using DFS/BFS; O(H) auxiliary space.</li>
        </ul>
      </section>

      <section id="conclusion" class="card">
        <h2>Conclusion</h2>
        <ul>
          <li>Binary trees model hierarchical data with at most two children per node.</li>
          <li>Recognize key types and their invariants: full, complete, perfect, balanced, degenerate.</li>
          <li>Efficient traversals and property checks run in O(N) time.</li>
          <li>Balanced height enables near-logarithmic operation costs in tree-based structures.</li>
        </ul>

        <h3>Interactive Quiz</h3>
        <div class="quiz" id="quiz">
          <!-- Q1 MCQ -->
          <div class="q">
            <div><b>1) Which statement best defines a binary tree?</b></div>
            <label class="choice"><input type="radio" name="q1"> A tree where each node has at most three children</label>
            <label class="choice"><input type="radio" name="q1"> A hierarchical structure where each node has at most two children</label>
            <label class="choice"><input type="radio" name="q1"> A linear list of nodes</label>
            <label class="choice"><input type="radio" name="q1"> A graph with cycles</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">A hierarchical structure where each node has at most two children.</div></details>
          </div>

          <!-- Q2 MCQ -->
          <div class="q">
            <div><b>2) In a full binary tree, each node has:</b></div>
            <label class="choice"><input type="radio" name="q2"> Either 0 or 2 children</label>
            <label class="choice"><input type="radio" name="q2"> At least 1 child</label>
            <label class="choice"><input type="radio" name="q2"> At most 1 child</label>
            <label class="choice"><input type="radio" name="q2"> Exactly 2 children</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">Either 0 or 2 children.</div></details>
          </div>

          <!-- Q3 SA -->
          <div class="q">
            <div><b>3) Short answer:</b> In a perfect binary tree of height h, how many nodes are there?</div>
            <button data-target="a3">Reveal answer</button>
            <div id="a3" class="ans">2^(h+1) - 1</div>
          </div>

          <!-- Q4 MCQ -->
          <div class="q">
            <div><b>4) Which property distinguishes a complete binary tree?</b></div>
            <label class="choice"><input type="radio" name="q4"> All leaves at the same level</label>
            <label class="choice"><input type="radio" name="q4"> All levels filled except possibly last; nodes as far left as possible</label>
            <label class="choice"><input type="radio" name="q4"> Every node has exactly two children</label>
            <label class="choice"><input type="radio" name="q4"> The height is exactly logâ‚‚(N)</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">All levels filled except possibly last; nodes as far left as possible.</div></details>
          </div>

          <!-- Q5 SA -->
          <div class="q">
            <div><b>5) Short answer:</b> List the four primary depth-first traversals discussed.</div>
            <button data-target="a5">Reveal answer</button>
            <div id="a5" class="ans">Preorder, Inorder, Postorder, and (breadth-first) Level-order was also covered separately.</div>
          </div>

          <!-- Q6 MCQ -->
          <div class="q">
            <div><b>6) Why are balanced trees desirable?</b></div>
            <label class="choice"><input type="radio" name="q6"> They guarantee O(1) time for all operations</label>
            <label class="choice"><input type="radio" name="q6"> They minimize memory usage</label>
            <label class="choice"><input type="radio" name="q6"> They keep height near O(log N), improving operation times</label>
            <label class="choice"><input type="radio" name="q6"> They avoid recursion</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">They keep height near O(log N), improving operation times.</div></details>
          </div>

          <!-- Q7 SA -->
          <div class="q">
            <div><b>7) Short answer:</b> What traversal yields sorted output for a Binary Search Tree?</div>
            <button data-target="a7">Reveal answer</button>
            <div id="a7" class="ans">Inorder traversal.</div>
          </div>

          <!-- Q8 MCQ -->
          <div class="q">
            <div><b>8) Which condition breaks completeness during level-order traversal?</b></div>
            <label class="choice"><input type="radio" name="q8"> Encountering a leaf</label>
            <label class="choice"><input type="radio" name="q8"> Seeing a non-null node after a null position</label>
            <label class="choice"><input type="radio" name="q8"> Visiting the right child before the left</label>
            <label class="choice"><input type="radio" name="q8"> Having different leaf depths</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">Seeing a non-null node after a null position.</div></details>
          </div>

          <!-- Q9 SA -->
          <div class="q">
            <div><b>9) Short answer:</b> Define a degenerate (skewed) tree in one sentence.</div>
            <button data-target="a9">Reveal answer</button>
            <div id="a9" class="ans">A tree in which each node has only one child, forming a list-like chain.</div>
          </div>

          <!-- Q10 MCQ -->
          <div class="q">
            <div><b>10) Which traversal is naturally implemented with a queue?</b></div>
            <label class="choice"><input type="radio" name="q10"> Preorder</label>
            <label class="choice"><input type="radio" name="q10"> Inorder</label>
            <label class="choice"><input type="radio" name="q10"> Postorder</label>
            <label class="choice"><input type="radio" name="q10"> Level-order</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">Level-order (BFS).</div></details>
          </div>

          <!-- Q11 SA -->
          <div class="q">
            <div><b>11) Short answer:</b> Give one criterion that makes a tree not full.</div>
            <button data-target="a11">Reveal answer</button>
            <div id="a11" class="ans">A node exists with exactly one child.</div>
          </div>

          <!-- Q12 MCQ -->
          <div class="q">
            <div><b>12) In a perfect tree, all leaves are:</b></div>
            <label class="choice"><input type="radio" name="q12"> At potentially different levels</label>
            <label class="choice"><input type="radio" name="q12"> At the same level</label>
            <label class="choice"><input type="radio" name="q12"> Absent</label>
            <label class="choice"><input type="radio" name="q12"> On the right-most side only</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">At the same level.</div></details>
          </div>
        </div>
      </section>

      <div class="footer-note">Optimized for quick revision. ðŸš€</div>
    </main>
  </div>

  <script>
    // Simple toggle for short-answer reveal buttons
    (function () {
      document.querySelectorAll('.quiz button[data-target]').forEach(function(btn) {
        btn.addEventListener('click', function() {
          var id = btn.getAttribute('data-target');
          var ans = document.getElementById(id);
          if (!ans) return;
          var visible = ans.style.display === 'block';
          ans.style.display = visible ? 'none' : 'block';
          btn.textContent = visible ? 'Reveal answer' : 'Hide answer';
        });
      });
    })();
  </script>
</body>
</html>

