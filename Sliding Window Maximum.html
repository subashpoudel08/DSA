<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sliding Window Maximum — Structured Notes</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --card: #0b1220;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #22d3ee;
      --accent-2: #a78bfa;
      --ok: #34d399;
      --warn: #fbbf24;
      --danger: #fb7185;
      --code-bg: #0b1020;
      --border: #1f2937;
      --shadow: 0 10px 30px rgba(0,0,0,0.45);
      --radius: 14px;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 80% -50%, #18263a 0%, var(--bg) 60%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.6;
      overflow-y: overlay;
    }
    .container {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 24px;
      max-width: 1200px;
      margin: 20px auto;
      padding: 0 16px 40px;
    }
    .sidebar {
      position: sticky; top: 20px; align-self: start;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid var(--border); border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 16px;
    }
    .sidebar h3 { margin: 0 0 10px; font-size: 16px; color: var(--muted); font-weight: 600; letter-spacing: .3px; }
    .toc { list-style: none; padding: 0; margin: 0; }
    .toc li { margin: 6px 0; }
    .toc a { display: block; text-decoration: none; color: var(--text); padding: 8px 10px; border-radius: 10px; transition: all .15s ease; border: 1px solid transparent; }
    .toc a:hover { background: #0b1220; border-color: var(--border); color: #ffffff; }
    .main { display: flex; flex-direction: column; gap: 18px; }
    .hero { position: relative; background: linear-gradient(180deg, rgba(167,139,250,0.10), rgba(34,211,238,0.06)); border: 1px solid var(--border); border-radius: var(--radius); padding: 26px 22px; box-shadow: var(--shadow); overflow: hidden; }
    .hero:after { content: ""; position: absolute; top: -40px; right: -60px; width: 220px; height: 220px; background: radial-gradient(120px 120px at 60% 40%, rgba(34,211,238,.35), rgba(34,211,238,0) 70%); filter: blur(6px); pointer-events: none; }
    .title { margin: 0; font-size: 28px; letter-spacing: .2px; }
    .subtitle { margin: 6px 0 0; color: var(--muted); }
    .chips { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    .chip { padding: 4px 8px; border: 1px solid var(--border); background: #0b1220; border-radius: 999px; color: var(--muted); font-size: 12px; }
    section.card { background: linear-gradient(180deg, rgba(255,255,255,0.035), rgba(255,255,255,0.015)); border: 1px solid var(--border); border-radius: var(--radius); padding: 18px 18px; box-shadow: var(--shadow); }
    h2 { margin: 0 0 10px; font-size: 20px; }
    h3 { margin: 16px 0 8px; font-size: 16px; color: var(--accent-2); }
    p { margin: 8px 0; }
    ul { margin: 8px 0 8px 18px; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    .note { color: var(--muted); font-size: 14px; }
    .pill { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; background: #0b1220; border: 1px solid var(--border); color: var(--text); font-size: 13px; }
    .pill b { color: var(--accent); }
    details { border: 1px solid var(--border); border-radius: 12px; background: #0b1220; }
    summary { list-style: none; cursor: pointer; padding: 12px 14px; font-weight: 600; color: #dbeafe; border-bottom: 1px solid var(--border); user-select: none; }
    summary::-webkit-details-marker { display:none; }
    .details-body { padding: 12px 14px; color: var(--text); }
    table { width: 100%; border-collapse: collapse; overflow: hidden; border-radius: 12px; }
    th, td { padding: 10px 12px; border-bottom: 1px solid var(--border); }
    th { text-align: left; color: #c7d2fe; font-weight: 600; background: rgba(167,139,250,0.08); }
    tr:last-child td { border-bottom: none; }
    pre, code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; padding: 12px; overflow: auto; }
    code { background: rgba(255,255,255,0.03); padding: 2px 6px; border-radius: 6px; border: 1px solid var(--border); color: #e2e8f0; }
    .callout { border-left: 3px solid var(--accent); background: linear-gradient(90deg, rgba(34,211,238,0.07), rgba(34,211,238,0.02)); padding: 10px 12px; border-radius: 10px; margin: 10px 0; }
    .formula { background: #0b1220; border: 1px dashed #1f334d; padding: 10px 12px; border-radius: 10px; }
    .footer-note { color: var(--muted); font-size: 13px; text-align: center; margin-top: 10px; }
    @media (max-width: 960px) { .container { grid-template-columns: 1fr; } .sidebar { position: static; order: -1; } }

    /* Quiz helpers */
    .quiz { display: grid; gap: 12px; }
    .quiz .q { border: 1px solid var(--border); border-radius: 12px; background: #0b1220; padding: 12px; }
    .quiz .choice { display: block; margin: 6px 0; }
    .quiz .ans { display: none; margin-top: 8px; color: var(--ok); }
    .quiz .reveal { margin-top: 8px; }
    .quiz button { background: #0b1220; color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 6px 10px; cursor: pointer; }
    .quiz button:hover { border-color: var(--accent); color: #ffffff; }
  </style>
</head>
<body>
  <div class="container">
    <aside class="sidebar">
      <h3>On this page</h3>
      <ul class="toc">
        <li><a href="#intro">Introduction</a></li>
        <li><a href="#example">Example & Breakdown</a></li>
        <li><a href="#brute">Brute-Force Baseline</a></li>
        <li><a href="#two-pass">Monotonic Deque Invariant</a></li>
        <li><a href="#single-pass">Single-Pass Deque Algorithm</a></li>
        <li><a href="#dry-run">Dry Run</a></li>
        <li><a href="#pseudocode">Pseudocode & Implementations</a></li>
        <li><a href="#conclusion">Conclusion + Quiz</a></li>
      </ul>
    </aside>

    <main class="main">
      <header class="hero">
        <h1 class="title">Sliding Window Maximum | Monotonic Deque</h1>
        <p class="subtitle">Given an array and an integer k, return the maximum for each contiguous subarray (window) of size k.</p>
        <div class="chips">
          <span class="chip">Deque</span>
          <span class="chip">Monotonic Queue</span>
          <span class="chip">O(N)</span>
          <span class="chip">Sliding Window</span>
          <span class="chip">Arrays</span>
        </div>
        <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
          <span class="pill"><b>Reading time:</b> ~10 min</span>
          <span class="pill"><b>Keywords:</b> sliding window maximum, monotonic deque, queue, O(N), indices</span>
        </div>
      </header>

      <section id="intro" class="card">
        <h2>Introduction</h2>
        <p>Problem: For an integer array <code>nums</code> and window size <code>k</code>, compute the maximum value for each window of length <code>k</code> as the window slides from left to right by one position at a time.</p>

        <h3>Summary</h3>
        <ul>
          <li>Maintain a <b>monotonically decreasing</b> deque of indices for elements in the current window.</li>
          <li>Before inserting a new index, remove indices from the back whose values are <b>less than or equal</b> to the new value.</li>
          <li>Remove the index at the front if it falls out of the window’s left boundary.</li>
          <li>The front of the deque always holds the index of the current window’s <b>maximum</b>.</li>
          <li>Each element is pushed and popped at most once ⇒ <b>O(N)</b> time, <b>O(k)</b> space.</li>
        </ul>
      </section>

      <section id="example" class="card">
        <h2>Example & Breakdown</h2>
        <p>Example: <code>nums = [1, 3, -1, -3, 5, 3, 2, 1, 6]</code>, <code>k = 3</code>.</p>
        <ul>
          <li>Window 1: <code>[1, 3, -1]</code> → max = <b>3</b> ⇒ result <code>[3]</code></li>
          <li>Window 2: <code>[3, -1, -3]</code> → max = <b>3</b> ⇒ <code>[3, 3]</code></li>
          <li>Window 3: <code>[-1, -3, 5]</code> → max = <b>5</b> ⇒ <code>[3, 3, 5]</code></li>
          <li>Window 4: <code>[-3, 5, 3]</code> → max = <b>5</b> ⇒ <code>[3, 3, 5, 5]</code></li>
          <li>Window 5: <code>[5, 3, 2]</code> → max = <b>5</b> ⇒ <code>[3, 3, 5, 5, 5]</code></li>
          <li>Window 6: <code>[3, 2, 1]</code> → max = <b>3</b> ⇒ <code>[3, 3, 5, 5, 5, 3]</code></li>
          <li>Window 7: <code>[2, 1, 6]</code> → max = <b>6</b> ⇒ <code>[3, 3, 5, 5, 5, 3, 6]</code></li>
        </ul>
        <div class="callout">Core idea: Keep only useful indices in decreasing order so the leftmost index is always the maximum of the current window.</div>
      </section>

      <section id="brute" class="card">
        <h2>Brute-Force Baseline</h2>
        <ul>
          <li>For each start index <code>i</code> from <code>0</code> to <code>n - k</code>, scan the next <code>k</code> elements and compute the maximum.</li>
          <li>Store each window’s max into a result list and return it at the end.</li>
          <li><b>Time:</b> <code>O((n-k+1) * k)</code> ≈ <code>O(nk)</code>. <b>Space:</b> <code>O(n-k+1)</code> for results.</li>
          <li>Repeated scanning is the inefficiency that the deque approach eliminates.</li>
        </ul>
      </section>

      <section id="two-pass" class="card">
        <h2>Monotonic Deque Invariant</h2>
        <p>Maintain a deque of <b>indices</b> such that their corresponding values are in <b>non-increasing</b> order from front to back.</p>
        <ul>
          <li><b>Window validity:</b> If the index at the front is out of range (≤ <code>i - k</code>), pop from the front.</li>
          <li><b>Monotonic maintenance:</b> While <code>nums[dq.back] ≤ nums[i]</code>, pop from the back; then push <code>i</code>.</li>
          <li><b>Result readout:</b> When <code>i ≥ k - 1</code>, the current max is <code>nums[dq.front]</code>.</li>
          <li><b>Why indices?</b> To quickly determine if an element has slid out of the window without extra data structures.</li>
        </ul>
      </section>

      <section id="single-pass" class="card">
        <h2>Single-Pass Deque Algorithm</h2>
        <ul>
          <li>Initialize an empty deque <code>dq</code> (stores indices) and an empty list <code>ans</code>.</li>
          <li>For each index <code>i</code> in <code>[0..n-1]</code>:
            <ul>
              <li>Remove out-of-window indices: while <code>dq</code> not empty and <code>dq.front ≤ i - k</code>, pop front.</li>
              <li>Maintain decreasing order: while <code>dq</code> not empty and <code>nums[dq.back] ≤ nums[i]</code>, pop back.</li>
              <li>Push current index <code>i</code> to back.</li>
              <li>If <code>i ≥ k - 1</code>, append <code>nums[dq.front]</code> to <code>ans</code>.</li>
            </ul>
          </li>
          <li>Return <code>ans</code>.</li>
        </ul>
        <p class="note">Using indices ensures O(1) checks for window boundaries and allows duplicates to be handled correctly.</p>
      </section>

      <section id="dry-run" class="card">
        <h2>Dry Run</h2>
        <p>Input: <code>nums = [1, 3, -1, -3, 5, 3, 2, 1, 6]</code>, <code>k = 3</code></p>
        <div class="details-body">
          <ul>
            <li>Start: <code>dq = []</code>, <code>ans = []</code></li>
            <li>i=0, val=1: dq empty → push 0 ⇒ dq=[0]</li>
            <li>i=1, val=3: nums[dq.back]=1 ≤ 3 → pop 0; push 1 ⇒ dq=[1]</li>
            <li>i=2, val=-1: -1 ≤ 3? yes; but we only pop if ≤ current, and we compare from back: 3 ≤ -1? no → push 2 ⇒ dq=[1,2]; i≥2 ⇒ ans=[nums[1]]= [3]</li>
            <li>i=3, val=-3: out-of-window? dq.front=1 ≤ 3-3? 1 ≤ 0 false; maintain: nums[2]=-1 ≤ -3? no → push 3 ⇒ dq=[1,2,3]; i≥2 ⇒ ans=[3, nums[1]=3] → [3,3]</li>
            <li>i=4, val=5: out-of-window? dq.front=1 ≤ 1 true → pop front ⇒ dq=[2,3]; maintain: nums[3]=-3 ≤ 5 pop; nums[2]=-1 ≤ 5 pop; dq empty → push 4 ⇒ dq=[4]; ans=[3,3, nums[4]=5] → [3,3,5]</li>
            <li>i=5, val=3: out-of-window? dq.front=4 ≤ 2 false; maintain: nums[4]=5 ≤ 3? no → push 5 ⇒ dq=[4,5]; ans=[3,3,5, nums[4]=5] → [3,3,5,5]</li>
            <li>i=6, val=2: out-of-window? 4 ≤ 3 false; maintain: nums[5]=3 ≤ 2? no → push 6 ⇒ dq=[4,5,6]; ans append nums[4]=5 ⇒ [3,3,5,5,5]</li>
            <li>i=7, val=1: out-of-window? 4 ≤ 4 true → pop front ⇒ dq=[5,6]; maintain: nums[6]=2 ≤ 1? no → push 7 ⇒ dq=[5,6,7]; ans append nums[5]=3 ⇒ [3,3,5,5,5,3]</li>
            <li>i=8, val=6: out-of-window? 5 ≤ 5 true → pop ⇒ dq=[6,7]; maintain: nums[7]=1 ≤ 6 pop; nums[6]=2 ≤ 6 pop; dq=[] push 8 ⇒ dq=[8]; ans append nums[8]=6 ⇒ [3,3,5,5,5,3,6]</li>
          </ul>
        </div>
        <div class="callout"><b>Edge cases:</b> k=1 ⇒ every element is a window; k=n ⇒ single result is max(nums); handles duplicates and negatives naturally.</div>
      </section>

      <section id="pseudocode" class="card">
        <h2>Pseudocode & Implementations</h2>
        <pre><code class="language-text">function slidingWindowMaximum(nums, k):
    n = length(nums)
    ans = empty list
    dq = empty deque   # stores indices, values are decreasing: nums[dq[0]] ≥ ... ≥ nums[dq[-1]]

    for i in 0..n-1:
        # 1) Remove out-of-window indices
        if dq not empty and dq.front() ≤ i - k:
            dq.pop_front()

        # 2) Maintain decreasing order by value
        while dq not empty and nums[dq.back()] ≤ nums[i]:
            dq.pop_back()

        # 3) Push current index
        dq.push_back(i)

        # 4) Emit current max
        if i ≥ k - 1:
            ans.append(nums[dq.front()])

    return ans
</code></pre>

        <h3>C++ Implementation</h3>
        <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;deque&gt;
using namespace std;

class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;& nums, int k) {
        int n = static_cast&lt;int&gt;(nums.size());
        if (n == 0 || k == 0) return {};
        deque&lt;int&gt; dq; // indices with decreasing values
        vector&lt;int&gt; ans;
        ans.reserve(n - k + 1);

        for (int i = 0; i &lt; n; ++i) {
            // remove out-of-window indices
            if (!dq.empty() &amp;&amp; dq.front() &lt;= i - k) dq.pop_front();

            // maintain decreasing order
            while (!dq.empty() &amp;&amp; nums[dq.back()] &lt;= nums[i]) dq.pop_back();

            dq.push_back(i);

            if (i &gt;= k - 1) ans.push_back(nums[dq.front()]);
        }
        return ans;
    }
};
</code></pre>

        <h3>Java Implementation</h3>
        <pre><code class="language-java">import java.util.Deque;
import java.util.ArrayDeque;

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        if (n == 0 || k == 0) return new int[0];

        int[] ans = new int[n - k + 1];
        Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;(); // indices with decreasing values

        for (int i = 0; i &lt; n; i++) {
            // remove out-of-window indices
            if (!dq.isEmpty() &amp;&amp; dq.peekFirst() &lt;= i - k) dq.pollFirst();

            // maintain decreasing order
            while (!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt;= nums[i]) dq.pollLast();

            dq.offerLast(i);

            if (i &gt;= k - 1) {
                ans[i - k + 1] = nums[dq.peekFirst()];
            }
        }
        return ans;
    }
}
</code></pre>

        <h3>Complexity</h3>
        <ul>
          <li><b>Time:</b> Each index is pushed once and popped at most once ⇒ <b>O(N)</b>.</li>
          <li><b>Space:</b> Deque holds at most <code>k</code> indices ⇒ <b>O(k)</b>; result is <code>O(n-k+1)</code>.</li>
        </ul>
      </section>

      <section id="conclusion" class="card">
        <h2>Conclusion</h2>
        <ul>
          <li>A monotonic deque yields window maxima in linear time without rescanning.</li>
          <li>Store <b>indices</b>, drop out-of-window from the front, and smaller-or-equal from the back.</li>
          <li>Front of the deque always points to the current window’s maximum.</li>
          <li>Robust across negatives and duplicates; scales to large inputs.</li>
        </ul>

        <h3>Interactive Quiz</h3>
        <div class="quiz" id="quiz">
          <!-- Q1 MCQ -->
          <div class="q">
            <div><b>1) What does the deque store in this approach?</b></div>
            <label class="choice"><input type="radio" name="q1"> Values only</label>
            <label class="choice"><input type="radio" name="q1"> Indices of elements</label>
            <label class="choice"><input type="radio" name="q1"> Prefix sums</label>
            <label class="choice"><input type="radio" name="q1"> Window boundaries</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">Indices of elements.</div></details>
          </div>

          <!-- Q2 MCQ -->
          <div class="q">
            <div><b>2) What order is maintained in the deque (by value)?</b></div>
            <label class="choice"><input type="radio" name="q2"> Strictly increasing</label>
            <label class="choice"><input type="radio" name="q2"> Non-decreasing</label>
            <label class="choice"><input type="radio" name="q2"> Strictly decreasing</label>
            <label class="choice"><input type="radio" name="q2"> Non-increasing</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">Non-increasing (monotonically decreasing) from front to back.</div></details>
          </div>

          <!-- Q3 SA -->
          <div class="q">
            <div><b>3) Short answer:</b> Why are elements popped from the back when inserting a larger or equal value?</div>
            <button data-target="a3">Reveal answer</button>
            <div id="a3" class="ans">Smaller-or-equal values cannot be the maximum while a newer, greater-or-equal value is in the same or future windows.</div>
          </div>

          <!-- Q4 MCQ -->
          <div class="q">
            <div><b>4) When is the front index removed?</b></div>
            <label class="choice"><input type="radio" name="q4"> When its value is less than the current value</label>
            <label class="choice"><input type="radio" name="q4"> When it falls out of the window (index ≤ i - k)</label>
            <label class="choice"><input type="radio" name="q4"> Every k steps</label>
            <label class="choice"><input type="radio" name="q4"> Never</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">When it falls out of the window (index ≤ i - k).</div></details>
          </div>

          <!-- Q5 SA -->
          <div class="q">
            <div><b>5) Short answer:</b> For <code>nums=[1,3,-1,-3,5,3,2,1,6]</code> and <code>k=3</code>, what is the output?</div>
            <button data-target="a5">Reveal answer</button>
            <div id="a5" class="ans">[3, 3, 5, 5, 5, 3, 6]</div>
          </div>

          <!-- Q6 MCQ -->
          <div class="q">
            <div><b>6) What is the time complexity of the deque solution?</b></div>
            <label class="choice"><input type="radio" name="q6"> O(nk)</label>
            <label class="choice"><input type="radio" name="q6"> O(n log k)</label>
            <label class="choice"><input type="radio" name="q6"> O(n)</label>
            <label class="choice"><input type="radio" name="q6"> O(k)</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">O(n).</div></details>
          </div>

          <!-- Q7 SA -->
          <div class="q">
            <div><b>7) Short answer:</b> Why do we store indices instead of values?</div>
            <button data-target="a7">Reveal answer</button>
            <div id="a7" class="ans">To quickly detect whether an element is out of the current window and to index into the original array.</div>
          </div>

          <!-- Q8 MCQ -->
          <div class="q">
            <div><b>8) Which operation provides the current window’s maximum?</b></div>
            <label class="choice"><input type="radio" name="q8"> The last index in the deque</label>
            <label class="choice"><input type="radio" name="q8"> The middle index in the deque</label>
            <label class="choice"><input type="radio" name="q8"> The front index in the deque</label>
            <label class="choice"><input type="radio" name="q8"> A full scan of k elements</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">The front index in the deque.</div></details>
          </div>

          <!-- Q9 SA -->
          <div class="q">
            <div><b>9) Short answer:</b> What happens when <code>k = 1</code>?</div>
            <button data-target="a9">Reveal answer</button>
            <div id="a9" class="ans">Every element forms a window, so the output equals the original array.</div>
          </div>

          <!-- Q10 SA -->
          <div class="q">
            <div><b>10) Short answer:</b> What happens when <code>k = n</code> for an array of length n?</div>
            <button data-target="a10">Reveal answer</button>
            <div id="a10" class="ans">There is one window, and the single output is max(nums).</div>
          </div>

          <!-- Q11 MCQ -->
          <div class="q">
            <div><b>11) Which condition preserves the deque’s monotonic property?</b></div>
            <label class="choice"><input type="radio" name="q11"> While nums[dq.back] ≥ nums[i], pop back</label>
            <label class="choice"><input type="radio" name="q11"> While nums[dq.back] ≤ nums[i], pop back</label>
            <label class="choice"><input type="radio" name="q11"> Always pop back, then push</label>
            <label class="choice"><input type="radio" name="q11"> Never pop back</label>
            <details class="reveal"><summary>Show answer</summary><div class="details-body">While nums[dq.back] ≤ nums[i], pop back.</div></details>
          </div>

          <!-- Q12 SA -->
          <div class="q">
            <div><b>12) Short answer:</b> Name two advantages of using a deque over the brute-force approach.</div>
            <button data-target="a12">Reveal answer</button>
            <div id="a12" class="ans">Linear time by avoiding rescans; constant-time access to the current window maximum via the front index.</div>
          </div>
        </div>
      </section>

      <div class="footer-note">Optimized for quick revision. 🚀</div>
    </main>
  </div>

  <script>
    // Simple toggle for short-answer reveal buttons
    (function () {
      document.querySelectorAll('.quiz button[data-target]').forEach(function(btn) {
        btn.addEventListener('click', function() {
          var id = btn.getAttribute('data-target');
          var ans = document.getElementById(id);
          if (!ans) return;
          var visible = ans.style.display === 'block';
          ans.style.display = visible ? 'none' : 'block';
          btn.textContent = visible ? 'Reveal answer' : 'Hide answer';
        });
      });
    })();
  </script>
</body>
</html>
